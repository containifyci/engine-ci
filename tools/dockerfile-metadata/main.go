package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const multiVariantTemplate = `// Code generated by dockerfile-metadata. DO NOT EDIT.

package {{ .Package }}
{{ range .Variants }}
{{ if .IsDefault }}
// Default Dockerfile ({{ .InputFile }})
const (
	// GoVersion is the golang version extracted from the Dockerfile
	GoVersion = "{{ .Version }}"

	// DockerfileChecksum is the checksum of the Dockerfile content
	DockerfileChecksum = "{{ .Checksum }}"
)

// DockerfileContent contains the embedded Dockerfile content
var DockerfileContent = ` + "`" + `{{ .Content }}` + "`" + `
{{ else }}
// {{ .VariantName }} variant ({{ .InputFile }})
const (
	// GoVersion{{ .VariantSuffix }} is the golang version extracted from the Dockerfile
	GoVersion{{ .VariantSuffix }} = "{{ .Version }}"

	// DockerfileChecksum{{ .VariantSuffix }} is the checksum of the Dockerfile content
	DockerfileChecksum{{ .VariantSuffix }} = "{{ .Checksum }}"
)

// DockerfileContent{{ .VariantSuffix }} contains the embedded Dockerfile content
var DockerfileContent{{ .VariantSuffix }} = ` + "`" + `{{ .Content }}` + "`" + `
{{ end }}
{{ end }}
// GetDockerfileMetadata returns the metadata for the specified variant type.
// Pass empty string "" for default variant{{ range .Variants }}{{ if not .IsDefault }}, or "{{ .VariantName }}" for {{ .VariantName }} variant{{ end }}{{ end }}.
func GetDockerfileMetadata(variantType string) (version, checksum, content string) {
	switch variantType {
	{{ range .Variants }}{{ if not .IsDefault }}case "{{ .VariantName }}":
		return GoVersion{{ .VariantSuffix }}, DockerfileChecksum{{ .VariantSuffix }}, DockerfileContent{{ .VariantSuffix }}
	{{ end }}{{ end }}default: // "" or any unknown type defaults to standard
		return GoVersion, DockerfileChecksum, DockerfileContent
	}
}
`

type VariantData struct {
	InputFile     string
	VariantName   string
	VariantSuffix string
	Version       string
	Checksum      string
	Content       string
	IsDefault     bool
}

type TemplateData struct {
	Package  string
	Variants []VariantData
}

type arrayFlags []string

func (i *arrayFlags) String() string {
	return strings.Join(*i, ", ")
}

func (i *arrayFlags) Set(value string) error {
	*i = append(*i, value)
	return nil
}

func main() {
	var (
		inputFiles arrayFlags
		variants   arrayFlags
		outputFile string
		pkgName    string
	)

	flag.Var(&inputFiles, "input", "Path to input Dockerfile (can be specified multiple times)")
	flag.Var(&variants, "variant", "Variant name corresponding to each input (can be specified multiple times, use empty string \"\" for default)")
	flag.StringVar(&outputFile, "output", "", "Path to output Go file")
	flag.StringVar(&pkgName, "package", "", "Package name for generated file")
	flag.Parse()

	if len(inputFiles) == 0 || outputFile == "" || pkgName == "" {
		flag.Usage()
		log.Fatal("Required flags: -input (1+), -output, -package")
	}

	if len(variants) > 0 && len(variants) != len(inputFiles) {
		log.Fatal("Number of -variant flags must match number of -input flags (or omit -variant entirely)")
	}

	// If no variants specified, assume first is default
	if len(variants) == 0 {
		variants = make([]string, len(inputFiles))
		variants[0] = "" // First is default
		for i := 1; i < len(inputFiles); i++ {
			variants[i] = fmt.Sprintf("variant%d", i)
		}
	}

	templateData := TemplateData{
		Package:  pkgName,
		Variants: make([]VariantData, 0, len(inputFiles)),
	}

	for i, inputFile := range inputFiles {
		variant := variants[i]

		// Read Dockerfile
		dockerfileContent, err := os.ReadFile(inputFile)
		if err != nil {
			log.Fatalf("Failed to read Dockerfile %s: %v", inputFile, err)
		}

		// Parse Dockerfile to extract version
		p := New(dockerfileContent)
		fromStatements, err := p.ParseFrom()
		if err != nil {
			log.Fatalf("Failed to parse Dockerfile %s: %v", inputFile, err)
		}

		if len(fromStatements) == 0 {
			log.Fatalf("No FROM statement found in Dockerfile %s", inputFile)
		}

		version := fromStatements[0].BaseVersion
		checksum := ComputeChecksum(dockerfileContent)

		// Create variant suffix (capitalize first letter)
		variantSuffix := ""
		if variant != "" {
			variantSuffix = strings.ToUpper(variant[:1]) + variant[1:]
		}

		variantData := VariantData{
			InputFile:     filepath.Base(inputFile),
			VariantName:   variant,
			VariantSuffix: variantSuffix,
			Version:       version,
			Checksum:      checksum,
			Content:       string(dockerfileContent),
			IsDefault:     variant == "",
		}

		templateData.Variants = append(templateData.Variants, variantData)

		fmt.Printf("Processed %s (variant=%q, version=%s, checksum=%s)\n",
			inputFile, variant, version, checksum[:16]+"...")
	}

	// Parse and execute template
	tmpl, err := template.New("generated").Parse(multiVariantTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated code: %v\nGenerated code:\n%s", err, buf.String())
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputFile)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		log.Fatalf("Failed to create output directory %s: %v", outputDir, err)
	}

	// Write output file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		log.Fatalf("Failed to write output file %s: %v", outputFile, err)
	}

	fmt.Printf("Generated %s with %d variant(s)\n", outputFile, len(templateData.Variants))
}

// ComputeChecksum computes SHA256 checksum with memory optimizations
// Uses streaming approach and buffer pooling for better performance
func ComputeChecksum(data []byte) string {

	// For very small data, use direct approach to avoid overhead
	if len(data) <= 4096 { // 4KB threshold - reduced for better performance
		hash := sha256.Sum256(data)
		result := hex.EncodeToString(hash[:])
		return result
	}

	// For larger data, use direct SHA256 approach (58% faster than buffer pool)
	hasher := sha256.New()
	hasher.Write(data)
	hashBytes := hasher.Sum(nil)
	result := hex.EncodeToString(hashBytes)

	return result
}
